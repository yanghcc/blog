(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{334:function(t,e,a){"use strict";a.r(e);var s=a(1),n=Object(s.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"移动端click延迟及zepto的穿透现象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#移动端click延迟及zepto的穿透现象","aria-hidden":"true"}},[t._v("#")]),t._v(" 移动端click延迟及zepto的穿透现象")]),t._v(" "),a("p",[t._v("穿透现象与click的延迟解决方法是分不开的，若要了解穿透现象，需要先了解click延迟的解决原理。")]),t._v(" "),a("h3",{attrs:{id:"移动端click事件300ms的延迟现象的原因："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#移动端click事件300ms的延迟现象的原因：","aria-hidden":"true"}},[t._v("#")]),t._v(" 移动端click事件300ms的延迟现象的原因：")]),t._v(" "),a("p",[t._v("在最早iphone的safar浏览器中，为了实现触屏中双击放大效果，当用户点击屏幕时后会判断在300ms内是否有第二次点击，如果有，就理解成双击，若没有就是单击, 就会触发click事件. 当你点击移动设备的屏幕时, 可以分解成多个事件，顺序依次为：touchstart — touchmove — touchend — click, 这些事件是按顺序依次触发的.")]),t._v(" "),a("h3",{attrs:{id:"解决延迟的思路："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决延迟的思路：","aria-hidden":"true"}},[t._v("#")]),t._v(" 解决延迟的思路：")]),t._v(" "),a("p",[t._v("touchstart touchend是没有延迟的，可以在touchend时触发用户想要在click时触发的事件.")]),t._v(" "),a("h3",{attrs:{id:"zepto-解决click延迟的原理："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#zepto-解决click延迟的原理：","aria-hidden":"true"}},[t._v("#")]),t._v(" zepto 解决click延迟的原理：")]),t._v(" "),a("p",[t._v("自定义tap事件，当用户点击元素时，touchend事件先发生, 当touchend事件冒泡到document时触发目标元素绑定的tap事件")]),t._v(" "),a("p",[t._v("简单模拟zepto tap的实现方式（这里忽略touchstart与touchend的点击位置的判断）：")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// document元素上绑定touchend事件, 在touchend的事件处理函数中自定义tap事件, 当点击的目标元素的touchend事件冒泡到document上时, 触发绑定在目标元素上的tap事件\ndocument.addEventListener('touchend', function(e) {\n  // 自定义tap事件\n  var evt = document.createEvent('Event');\n  evt.init(’tap’, true, true);\n\n  // 触发绑定在目标元素上的tap事件\n  e.target.dispatch(evt);\n}, false);\n// -----------------------------------------------------------------\n// 用户绑定tap事件\ndocument.getElementById(‘elementid’).addEventListener('tap’, function(e) {\n  // click事件逻辑\n}, false);\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br"),a("span",{staticClass:"line-number"},[t._v("12")]),a("br"),a("span",{staticClass:"line-number"},[t._v("13")]),a("br"),a("span",{staticClass:"line-number"},[t._v("14")]),a("br")])]),a("h3",{attrs:{id:"zepto的tap穿透现象："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#zepto的tap穿透现象：","aria-hidden":"true"}},[t._v("#")]),t._v(" zepto的tap穿透现象：")]),t._v(" "),a("p",[t._v("遮罩层中有一个标签绑定了tap事件，触发时遮罩层消失，该标签正下方有一个绑定了click的按钮，此时点击上层的标签，同时也会触发下层元素的click事件，出现穿透的现象。")]),t._v(" "),a("h3",{attrs:{id:"为什么会出现穿透："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么会出现穿透：","aria-hidden":"true"}},[t._v("#")]),t._v(" 为什么会出现穿透：")]),t._v(" "),a("p",[t._v("结合前面tap事件的原理来分析：")]),t._v(" "),a("p",[t._v("当触发tap事件，上层遮罩层关闭后，此时事件只进行到touchend，而click是在大概300ms后才触发，当click触发时，上面的遮罩层已消失，就相当于点击到了下层的元素。")]),t._v(" "),a("h3",{attrs:{id:"下层什么样的元素才会形成穿透："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#下层什么样的元素才会形成穿透：","aria-hidden":"true"}},[t._v("#")]),t._v(" 下层什么样的元素才会形成穿透：")]),t._v(" "),a("p",[t._v("根据原理来说，因为穿透是发生在click发生时，也就是下层绑定了click事件或click时会触发的事件（focus focusout）的元素，或点击时有默认形为的标签元素，如a input(会出系统键盘的type类型或绑定了focus事件)等。")]),t._v(" "),a("h1",{attrs:{id:"如何解决穿透："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何解决穿透：","aria-hidden":"true"}},[t._v("#")]),t._v(" 如何解决穿透：")]),t._v(" "),a("p",[t._v("方法一：直接将上层元素的tap事件换成click事件（会出现300ms的延迟触发事件）")]),t._v(" "),a("p",[t._v("方法二：在click事件触发前阻止它，如在touchend的事件中使用e.preventDefault()来阻止后续的click事件")]),t._v(" "),a("h1",{attrs:{id:"zepto为何不使用e-preventdefault-来解决穿透问题？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#zepto为何不使用e-preventdefault-来解决穿透问题？","aria-hidden":"true"}},[t._v("#")]),t._v(" zepto为何不使用e.preventDefault()来解决穿透问题？")]),t._v(" "),a("p",[t._v("因为zepto的tap事件统一是在document的touchend时触发的，若在这里使用e.preventDefault()，那页面上所有元素在touchend后触发的事件都不会被执行了。")])])}],!1,null,null,null);e.default=n.exports}}]);